// Code generated by generate_flags, DO NOT EDIT!
package {{.Package}}

import (
	"errors"
	"fmt"
	"net"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"github.com/streamingfast/cli"
)

var ErrViperTypeNotSupported = errors.New("viper type not supported")

type ErrFlagNotExist struct {
	Name string
}

func (e *ErrFlagNotExist) Error() string {
	return fmt.Sprintf("flag %q does not exist", e.Name)
}

{{range .Definitions}}
// MustGet{{.Name | pascalCase}}Provided is exactly like [MustGet{{.Name | pascalCase}}] but also
// return if the key was changed somewhere in the configuration stack.
func MustGet{{.Name | pascalCase}}Provided(cmd *cobra.Command, name string) ({{.Type}}, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		{{- if eq .ViperName "" }}
		cli.Quit(`Viper does not support get value for type "{{.Name | pascalCase}}" requested via flag %q (key %q)`, name, reboundKey)
		{{- else if eq .ViperCast "" }}
		return viper.Get{{.ViperName | pascalCase}}(reboundKey), viper.IsSet(reboundKey)
		{{- else }}
		return {{ .ViperCast }}(viper.Get{{.ViperName | pascalCase}}(reboundKey)), viper.IsSet(reboundKey)
		{{- end }}
	}

	out, err := cmd.Flags().Get{{.Name | pascalCase}}(name)
	cli.NoError(err, `Read flag %q via "Get{{.Name | pascalCase }}" failed`, name)

	return out, flag.Changed
}

// MustGet{{.Name | pascalCase}} returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [cli.ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get{{.ViperName | pascalCase}}]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().Get{{.Name | pascalCase}}(name)`
//
// See [cli.ConfigureViper] for key rebinding rules.
func MustGet{{.Name | pascalCase}}(cmd *cobra.Command, name string) {{.Type}} {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		{{- if eq .ViperName "" }}
		cli.Quit(`Viper does not support get value for type "{{.Name | pascalCase}}" requested via flag %q (key %q)`, name, reboundKey)
		{{- else if eq .ViperCast "" }}
		return viper.Get{{.ViperName | pascalCase}}(reboundKey)
		{{- else }}
		return {{ .ViperCast }}(viper.Get{{.ViperName | pascalCase}}(reboundKey))
		{{- end }}
	}

	out, err := cmd.Flags().Get{{.Name | pascalCase}}(name)
	cli.NoError(err, `Read flag %q via "Get{{.Name | pascalCase }}" failed`, name)

	return out
}

// Get{{.Name | pascalCase}} returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [cli.ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get{{.ViperName | pascalCase}}]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().Get{{.Name | pascalCase}}(name)`
//
// See [cli.ConfigureViper] for key rebinding rules.
func Get{{.Name | pascalCase}}(cmd *cobra.Command, name string) (out {{.Type}}, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		{{- if eq .ViperName "" }}
		return out, fmt.Errorf(`%w: unsupported type "{{.Name | pascalCase}}" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
		{{- else if eq .ViperCast "" }}
		return viper.Get{{.ViperName | pascalCase}}(reboundKey), nil
		{{- else }}
		return {{ .ViperCast }}(viper.Get{{.ViperName | pascalCase}}(reboundKey)), nil
		{{- end }}
	}

	return cmd.Flags().Get{{.Name | pascalCase}}(name)
}
{{end}}

func getReboundKey(flag *pflag.Flag) (string, bool) {
	return getAnnotation(flag, cli.ReboundFlagAnnotation)
}

func getAnnotation(flag *pflag.Flag, key string) (string, bool) {
	if flag.Annotations == nil {
		return "", false
	}

	values := flag.Annotations[key]
	if len(values) == 0 {
		return "", false
	}

	return values[len(values)-1], true
}